[{"title":"LegacyLoader","type":0,"sectionRef":"#","url":"/Evermore/api/LegacyLoader","content":"On this page LegacyLoader This item is only intended to be used by the module's authors. Private Legacy loading logic","keywords":""},{"title":"cancellableDelay","type":0,"sectionRef":"#","url":"/Evermore/api/cancellableDelay","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"cancellableDelay","url":"/Evermore/api/cancellableDelay#functions","content":" "},{"title":"cancellableDelay​","type":1,"pageTitle":"cancellableDelay","url":"/Evermore/api/cancellableDelay#cancellableDelay","content":"&lt;/&gt; cancellableDelay.cancellableDelay( timeoutInSeconds: number, func: function, ...: any-- Args to pass into the function ) → function?-- Can be used to cancel  "},{"title":"LoaderAdder","type":0,"sectionRef":"#","url":"/Evermore/api/LoaderAdder","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"LoaderAdder","url":"/Evermore/api/LoaderAdder#functions","content":" "},{"title":"Destroy​","type":1,"pageTitle":"LoaderAdder","url":"/Evermore/api/LoaderAdder#Destroy","content":"&lt;/&gt; LoaderAdder:Destroy() → () Cleans up the replicator disconnecting all events and cleaning up created instances.  "},{"title":"Destroy​","type":1,"pageTitle":"LoaderAdder","url":"/Evermore/api/LoaderAdder#Destroy","content":"&lt;/&gt; LoaderAdder:Destroy() → () Cleans up the replicator disconnecting all events and cleaning up created instances. "},{"title":"LoaderClass","type":0,"sectionRef":"#","url":"/Evermore/api/LoaderClass","content":"On this page LoaderClass This item is only intended to be used by the module's authors. Private Loading logic for Nevermore","keywords":""},{"title":"GroupInfoUtils","type":0,"sectionRef":"#","url":"/Evermore/api/GroupInfoUtils","content":"On this page GroupInfoUtils This item is only intended to be used by the module's authors. Private Nevermore loader utility library","keywords":""},{"title":"BounceTemplateUtils","type":0,"sectionRef":"#","url":"/Evermore/api/BounceTemplateUtils","content":"On this page BounceTemplateUtils This item is only intended to be used by the module's authors. Private","keywords":""},{"title":"LoaderUtils","type":0,"sectionRef":"#","url":"/Evermore/api/LoaderUtils","content":"On this page LoaderUtils This item is only intended to be used by the module's authors. Private","keywords":""},{"title":"ObservableSubscriptionTable","type":0,"sectionRef":"#","url":"/Evermore/api/ObservableSubscriptionTable","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"ObservableSubscriptionTable","url":"/Evermore/api/ObservableSubscriptionTable#functions","content":" "},{"title":"Fire​","type":1,"pageTitle":"ObservableSubscriptionTable","url":"/Evermore/api/ObservableSubscriptionTable#Fire","content":"&lt;/&gt; ObservableSubscriptionTable:Fire( key: TKey, ...: TEmit ) → () Fires for the current key the given value  "},{"title":"Observe​","type":1,"pageTitle":"ObservableSubscriptionTable","url":"/Evermore/api/ObservableSubscriptionTable#Observe","content":"&lt;/&gt; ObservableSubscriptionTable:Observe(key: TKey) → Observable&lt;TEmit&gt; Observes for the key  "},{"title":"Destroy​","type":1,"pageTitle":"ObservableSubscriptionTable","url":"/Evermore/api/ObservableSubscriptionTable#Destroy","content":"&lt;/&gt; ObservableSubscriptionTable:Destroy() → () Completes all subscriptions and removes them from the list. "},{"title":"deferred","type":0,"sectionRef":"#","url":"/Evermore/api/deferred","content":"On this page deferred This was deprecated in 2.0.1 This item is deprecated. Do not use it for new work. An expensive way to spawn a function. However, unlike spawn(), it executes on the same frame, and unlike coroutines, does not obscure errors","keywords":""},{"title":"PackageInfoUtils","type":0,"sectionRef":"#","url":"/Evermore/api/PackageInfoUtils","content":"On this page PackageInfoUtils This item is only intended to be used by the module's authors. Private Utility methods to build a virtual graph of the existing package information set","keywords":""},{"title":"PendingPromiseTracker","type":0,"sectionRef":"#","url":"/Evermore/api/PendingPromiseTracker","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"PendingPromiseTracker","url":"/Evermore/api/PendingPromiseTracker#functions","content":" "},{"title":"new​","type":1,"pageTitle":"PendingPromiseTracker","url":"/Evermore/api/PendingPromiseTracker#new","content":"&lt;/&gt; PendingPromiseTracker.new() → PendingPromiseTracker&lt;T&gt; Returns a new pending promise tracker  "},{"title":"Add​","type":1,"pageTitle":"PendingPromiseTracker","url":"/Evermore/api/PendingPromiseTracker#Add","content":"&lt;/&gt; PendingPromiseTracker:Add(promise: Promise&lt;T&gt;) → () Adds a new promise to the tracker. If it's not pending it will not add.  "},{"title":"GetAll​","type":1,"pageTitle":"PendingPromiseTracker","url":"/Evermore/api/PendingPromiseTracker#GetAll","content":"&lt;/&gt; PendingPromiseTracker:GetAll() → {Promise&lt;T&gt;} Gets all of the promises that are pending "},{"title":"Loader","type":0,"sectionRef":"#","url":"/Evermore/api/Loader","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Loader","url":"/Evermore/api/Loader#types","content":" "},{"title":"ModuleReference​","type":1,"pageTitle":"Loader","url":"/Evermore/api/Loader#ModuleReference","content":"&lt;/&gt; type ModuleReference = ModuleScript | number | string A type that can be loaded into a module  "},{"title":"ModuleReference​","type":1,"pageTitle":"Loader","url":"/Evermore/api/Loader#ModuleReference","content":"&lt;/&gt; type ModuleReference = ModuleScript | number | string A type that can be loaded into a module "},{"title":"Functions​","type":1,"pageTitle":"Loader","url":"/Evermore/api/Loader#functions","content":" "},{"title":"bootstrapGame​","type":1,"pageTitle":"Loader","url":"/Evermore/api/Loader#bootstrapGame","content":"This item only works when running on the server. Server &lt;/&gt; Loader.bootstrapGame(packageFolder: Instance ) → Folder -- serverFolder Bootstraps the game by replicating packages to server, client, and shared. local ServerScriptService = game:GetService(&quot;ServerScriptService&quot;) local loader = ServerScriptService:FindFirstChild(&quot;LoaderUtils&quot;, true).Parent local packages = require(loader).bootstrapGame(ServerScriptService.ik) info The game must be running to do this bootstrapping operation.  "},{"title":"load​","type":1,"pageTitle":"Loader","url":"/Evermore/api/Loader#load","content":"&lt;/&gt; Loader.load( script: Script -- The script to load dependencies for. ) → (moduleReference: ModuleReference) → any Returns a function that can be used to load modules relative to the script specified. local require = require(script.Parent.loader).load(script) local maid = require(&quot;Maid&quot;)   "},{"title":"bootstrapGame​","type":1,"pageTitle":"Loader","url":"/Evermore/api/Loader#bootstrapGame","content":"This item only works when running on the server. Server &lt;/&gt; Loader.bootstrapGame(packageFolder: Instance ) → Folder -- serverFolder Bootstraps the game by replicating packages to server, client, and shared. local ServerScriptService = game:GetService(&quot;ServerScriptService&quot;) local loader = ServerScriptService:FindFirstChild(&quot;LoaderUtils&quot;, true).Parent local packages = require(loader).bootstrapGame(ServerScriptService.ik) info The game must be running to do this bootstrapping operation.  "},{"title":"load​","type":1,"pageTitle":"Loader","url":"/Evermore/api/Loader#load","content":"&lt;/&gt; Loader.load( script: Script -- The script to load dependencies for. ) → (moduleReference: ModuleReference) → any Returns a function that can be used to load modules relative to the script specified. local require = require(script.Parent.loader).load(script) local maid = require(&quot;Maid&quot;)  "},{"title":"LoaderConstants","type":0,"sectionRef":"#","url":"/Evermore/api/LoaderConstants","content":"On this page LoaderConstants This item is only intended to be used by the module's authors. Private","keywords":""},{"title":"promisePropertyValue","type":0,"sectionRef":"#","url":"/Evermore/api/promisePropertyValue","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"promisePropertyValue","url":"/Evermore/api/promisePropertyValue#functions","content":" "},{"title":"promisePropertyValue​","type":1,"pageTitle":"promisePropertyValue","url":"/Evermore/api/promisePropertyValue#promisePropertyValue","content":"&lt;/&gt; promisePropertyValue.promisePropertyValue( instance: Instance , propertyName: string ) → Promise&lt;Instance &gt; Promise that resolves when the property value is truthy. warning To use properly please make sure to reject the promise for proper GC if the object requiring "},{"title":"CancelToken","type":0,"sectionRef":"#","url":"/Evermore/api/CancelToken","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"CancelToken","url":"/Evermore/api/CancelToken#functions","content":" "},{"title":"new​","type":1,"pageTitle":"CancelToken","url":"/Evermore/api/CancelToken#new","content":"&lt;/&gt; CancelToken.new(executor: (cancel: () → ()) → ()) → CancelToken Constructs a new CancelToken  "},{"title":"isCancelToken​","type":1,"pageTitle":"CancelToken","url":"/Evermore/api/CancelToken#isCancelToken","content":"&lt;/&gt; CancelToken.isCancelToken(value: any) → boolean Returns true if the value is a cancel token  "},{"title":"fromMaid​","type":1,"pageTitle":"CancelToken","url":"/Evermore/api/CancelToken#fromMaid","content":"&lt;/&gt; CancelToken.fromMaid(maid: Maid) → CancelToken Constructs a new CancelToken that cancels whenever the maid does.  "},{"title":"ErrorIfCancelled​","type":1,"pageTitle":"CancelToken","url":"/Evermore/api/CancelToken#ErrorIfCancelled","content":"&lt;/&gt; CancelToken:ErrorIfCancelled() → () Errors if cancelled  "},{"title":"IsCancelled​","type":1,"pageTitle":"CancelToken","url":"/Evermore/api/CancelToken#IsCancelled","content":"&lt;/&gt; CancelToken:IsCancelled() → boolean Returns true if cancelled "},{"title":"DependencyPath","type":0,"sectionRef":"#","url":"/Evermore/api/DependencyPath","content":"On this page DependencyPath","keywords":""},{"title":"MaidTaskUtils","type":0,"sectionRef":"#","url":"/Evermore/api/MaidTaskUtils","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"MaidTaskUtils","url":"/Evermore/api/MaidTaskUtils#types","content":" "},{"title":"Destructable​","type":1,"pageTitle":"MaidTaskUtils","url":"/Evermore/api/MaidTaskUtils#Destructable","content":"&lt;/&gt; type Destructable = Instance | {Destroy: function} An object that can have the method :Destroy() called on it  "},{"title":"MaidTask​","type":1,"pageTitle":"MaidTaskUtils","url":"/Evermore/api/MaidTaskUtils#MaidTask","content":"&lt;/&gt; type MaidTask = function | thread | Destructable | RBXScriptConnection  An object that can be cleaned up "},{"title":"Functions​","type":1,"pageTitle":"MaidTaskUtils","url":"/Evermore/api/MaidTaskUtils#functions","content":" "},{"title":"isValidTask​","type":1,"pageTitle":"MaidTaskUtils","url":"/Evermore/api/MaidTaskUtils#isValidTask","content":"&lt;/&gt; MaidTaskUtils.isValidTask(job: any) → boolean Returns whether a task is a valid job.  "},{"title":"doTask​","type":1,"pageTitle":"MaidTaskUtils","url":"/Evermore/api/MaidTaskUtils#doTask","content":"&lt;/&gt; MaidTaskUtils.doTask( job: MaidTask-- Task to execute ) → () Executes the task as requested.  "},{"title":"delayed​","type":1,"pageTitle":"MaidTaskUtils","url":"/Evermore/api/MaidTaskUtils#delayed","content":"&lt;/&gt; MaidTaskUtils.delayed( time: number,-- Time in seconds job: MaidTask-- Job to delay execution ) → () → ()-- function that will execute the job delayed Executes the task delayed after some time. -- delays cleanup by 5 seconds maid:GiveTask(MaidTaskUtils.delayed(5, gui))  "},{"title":"PromiseInstanceUtils","type":0,"sectionRef":"#","url":"/Evermore/api/PromiseInstanceUtils","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"PromiseInstanceUtils","url":"/Evermore/api/PromiseInstanceUtils#functions","content":" "},{"title":"promiseRemoved​","type":1,"pageTitle":"PromiseInstanceUtils","url":"/Evermore/api/PromiseInstanceUtils#promiseRemoved","content":"&lt;/&gt; PromiseInstanceUtils.promiseRemoved(instance: Instance ) → Promise Promise that resolves when an instance is removed "},{"title":"Observable","type":0,"sectionRef":"#","url":"/Evermore/api/Observable","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Observable","url":"/Evermore/api/Observable#functions","content":" "},{"title":"isObservable​","type":1,"pageTitle":"Observable","url":"/Evermore/api/Observable#isObservable","content":"&lt;/&gt; Observable.isObservable(item: any) → boolean Returns whether or not a value is an observable.  "},{"title":"new​","type":1,"pageTitle":"Observable","url":"/Evermore/api/Observable#new","content":"&lt;/&gt; Observable.new(onSubscribe: (subscription: Subscription&lt;T&gt;) → MaidTask) → Observable&lt;T&gt; Constructs a new Observable local function observeAllChildren(parent) return Observable.new(function(sub) local maid = Maid.new() for _, item in pairs(parent:GetChildren()) do sub:Fire(item) end maid:GiveTask(parent.ChildAdded:Connect(function(child) sub:Fire(child) end)) return maid end) end -- Prints out all current children, and whenever a new -- child is added to workspace local maid = Maid.new() maid:GiveTask(observeAllChildren(workspace):Subscribe(print))   "},{"title":"Pipe​","type":1,"pageTitle":"Observable","url":"/Evermore/api/Observable#Pipe","content":"&lt;/&gt; Observable:Pipe(transformers: {(observable: Observable&lt;T&gt;) → Observable&lt;T&gt;}) → Observable&lt;T&gt; Transforms the observable with the following transformers Rx.of(1, 2, 3):Pipe({ Rx.map(function(result) return result + 1 end); Rx.map(function(value) return (&quot;%0.2f&quot;):format(value) end); }):Subscribe(print) --&gt; 2.00 --&gt; 3.00 --&gt; 4.00   "},{"title":"Subscribe​","type":1,"pageTitle":"Observable","url":"/Evermore/api/Observable#Subscribe","content":"&lt;/&gt; Observable:Subscribe( fireCallback: function?, failCallback: function?, completeCallback: function? ) → MaidTask Subscribes immediately, fireCallback may return a maid (or a task a maid can handle) to clean up "},{"title":"BounceTemplate","type":0,"sectionRef":"#","url":"/Evermore/api/BounceTemplate","content":"On this page BounceTemplate This item is only intended to be used by the module's authors. Private Bounces the current named script to the expected version of this module","keywords":""},{"title":"promiseWait","type":0,"sectionRef":"#","url":"/Evermore/api/promiseWait","content":"On this page promiseWait Wraps the task.delay() API in a promise","keywords":""},{"title":"Queue","type":0,"sectionRef":"#","url":"/Evermore/api/Queue","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Queue","url":"/Evermore/api/Queue#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Queue","url":"/Evermore/api/Queue#new","content":"&lt;/&gt; Queue.new() → Queue&lt;T&gt; Constructs a new queue  "},{"title":"new​","type":1,"pageTitle":"Queue","url":"/Evermore/api/Queue#new","content":"&lt;/&gt; Queue.new() → Queue&lt;T&gt; Constructs a new queue  "},{"title":"PushLeft​","type":1,"pageTitle":"Queue","url":"/Evermore/api/Queue#PushLeft","content":"&lt;/&gt; Queue:PushLeft(value: T) → () Pushes an entry to the left of the queue  "},{"title":"PushRight​","type":1,"pageTitle":"Queue","url":"/Evermore/api/Queue#PushRight","content":"&lt;/&gt; Queue:PushRight(value: T) → () Pushes an entry to the right of the queue  "},{"title":"PopLeft​","type":1,"pageTitle":"Queue","url":"/Evermore/api/Queue#PopLeft","content":"&lt;/&gt; Queue:PopLeft() → T Pops an entry from the left of the queue  "},{"title":"PopRight​","type":1,"pageTitle":"Queue","url":"/Evermore/api/Queue#PopRight","content":"&lt;/&gt; Queue:PopRight() → T Pops an entry from the right of the queue  "},{"title":"IsEmpty​","type":1,"pageTitle":"Queue","url":"/Evermore/api/Queue#IsEmpty","content":"&lt;/&gt; Queue:IsEmpty() → boolean Returns true if the queue is empty  "},{"title":"PushLeft​","type":1,"pageTitle":"Queue","url":"/Evermore/api/Queue#PushLeft","content":"&lt;/&gt; Queue:PushLeft(value: T) → () Pushes an entry to the left of the queue  "},{"title":"PushRight​","type":1,"pageTitle":"Queue","url":"/Evermore/api/Queue#PushRight","content":"&lt;/&gt; Queue:PushRight(value: T) → () Pushes an entry to the right of the queue  "},{"title":"PopLeft​","type":1,"pageTitle":"Queue","url":"/Evermore/api/Queue#PopLeft","content":"&lt;/&gt; Queue:PopLeft() → T Pops an entry from the left of the queue  "},{"title":"PopRight​","type":1,"pageTitle":"Queue","url":"/Evermore/api/Queue#PopRight","content":"&lt;/&gt; Queue:PopRight() → T Pops an entry from the right of the queue  "},{"title":"IsEmpty​","type":1,"pageTitle":"Queue","url":"/Evermore/api/Queue#IsEmpty","content":"&lt;/&gt; Queue:IsEmpty() → boolean Returns true if the queue is empty "},{"title":"Set","type":0,"sectionRef":"#","url":"/Evermore/api/Set","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Set","url":"/Evermore/api/Set#functions","content":" "},{"title":"union​","type":1,"pageTitle":"Set","url":"/Evermore/api/Set#union","content":"&lt;/&gt; Set.union( set: table, otherSet: table ) → table Unions the set with the other set, making a copy.  "},{"title":"unionUpdate​","type":1,"pageTitle":"Set","url":"/Evermore/api/Set#unionUpdate","content":"&lt;/&gt; Set.unionUpdate( set: table, otherSet: table ) → table Unions the set with the other set, updating the set  "},{"title":"intersection​","type":1,"pageTitle":"Set","url":"/Evermore/api/Set#intersection","content":"&lt;/&gt; Set.intersection( set: table, otherSet: table ) → table Finds the set intersection betwen the two sets  "},{"title":"copy​","type":1,"pageTitle":"Set","url":"/Evermore/api/Set#copy","content":"&lt;/&gt; Set.copy(set: table) → table Makes a copy of the set, making the values as true.  "},{"title":"fromTableValue​","type":1,"pageTitle":"Set","url":"/Evermore/api/Set#fromTableValue","content":"&lt;/&gt; Set.fromTableValue(tab: table) → table Converts a set from table values.  "},{"title":"fromList​","type":1,"pageTitle":"Set","url":"/Evermore/api/Set#fromList","content":"&lt;/&gt; Set.fromList(tab: table) → table Converts a set from a list  "},{"title":"toList​","type":1,"pageTitle":"Set","url":"/Evermore/api/Set#toList","content":"&lt;/&gt; Set.toList(set: table) → table Converts a set to a list  "},{"title":"differenceUpdate​","type":1,"pageTitle":"Set","url":"/Evermore/api/Set#differenceUpdate","content":"&lt;/&gt; Set.differenceUpdate( set: table, otherSet: table ) → table Converts a set to a list  "},{"title":"difference​","type":1,"pageTitle":"Set","url":"/Evermore/api/Set#difference","content":"&lt;/&gt; Set.difference( set: table, otherSet: table ) → table Computes the set difference between the two sets "},{"title":"DependencyUtils","type":0,"sectionRef":"#","url":"/Evermore/api/DependencyUtils","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"DependencyUtils","url":"/Evermore/api/DependencyUtils#functions","content":" "},{"title":"findDependency​","type":1,"pageTitle":"DependencyUtils","url":"/Evermore/api/DependencyUtils#findDependency","content":"&lt;/&gt; DependencyUtils.findDependency( requester: Instance , moduleName: string ) → ModuleScript?  Iteratively searches for a dependency based upon packages and current modules using the node_modules dependency resolution algorithm.  "},{"title":"findDependency​","type":1,"pageTitle":"DependencyUtils","url":"/Evermore/api/DependencyUtils#findDependency","content":"&lt;/&gt; DependencyUtils.findDependency( requester: Instance , moduleName: string ) → ModuleScript?  Iteratively searches for a dependency based upon packages and current modules using the node_modules dependency resolution algorithm. "},{"title":"promiseChild","type":0,"sectionRef":"#","url":"/Evermore/api/promiseChild","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"promiseChild","url":"/Evermore/api/promiseChild#functions","content":" "},{"title":"promiseChild​","type":1,"pageTitle":"promiseChild","url":"/Evermore/api/promiseChild#promiseChild","content":"&lt;/&gt; promiseChild.promiseChild( parent: Instance , name: string, timeOut: number? ) → Promise&lt;Instance &gt; Wraps the :WaitForChild API with a promise "},{"title":"ReplicationType","type":0,"sectionRef":"#","url":"/Evermore/api/ReplicationType","content":"On this page ReplicationType Different replication types we can be in.","keywords":""},{"title":"ReplicationTypeUtils","type":0,"sectionRef":"#","url":"/Evermore/api/ReplicationTypeUtils","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"ReplicationTypeUtils","url":"/Evermore/api/ReplicationTypeUtils#functions","content":" "},{"title":"isReplicationType​","type":1,"pageTitle":"ReplicationTypeUtils","url":"/Evermore/api/ReplicationTypeUtils#isReplicationType","content":"&lt;/&gt; ReplicationTypeUtils.isReplicationType(replicationType: any) → boolean Returns true if the data is a replicationType  "},{"title":"isReplicationType​","type":1,"pageTitle":"ReplicationTypeUtils","url":"/Evermore/api/ReplicationTypeUtils#isReplicationType","content":"&lt;/&gt; ReplicationTypeUtils.isReplicationType(replicationType: any) → boolean Returns true if the data is a replicationType "},{"title":"StaticLegacyLoader","type":0,"sectionRef":"#","url":"/Evermore/api/StaticLegacyLoader","content":"On this page StaticLegacyLoader This item is only intended to be used by the module's authors. Private","keywords":""},{"title":"ScriptInfoUtils","type":0,"sectionRef":"#","url":"/Evermore/api/ScriptInfoUtils","content":"On this page ScriptInfoUtils This item is only intended to be used by the module's authors. Private","keywords":""},{"title":"Maid","type":0,"sectionRef":"#","url":"/Evermore/api/Maid","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Maid","url":"/Evermore/api/Maid#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Maid","url":"/Evermore/api/Maid#new","content":"&lt;/&gt; Maid.new() → Maid Constructs a new Maid object local maid = Maid.new()   "},{"title":"isMaid​","type":1,"pageTitle":"Maid","url":"/Evermore/api/Maid#isMaid","content":"&lt;/&gt; Maid.isMaid(value: any) → boolean Returns true if the class is a maid, and false otherwise. print(Maid.isMaid(Maid.new())) --&gt; true print(Maid.isMaid(nil)) --&gt; false   "},{"title":"Destroy​","type":1,"pageTitle":"Maid","url":"/Evermore/api/Maid#Destroy","content":"&lt;/&gt; Maid.Destroy() → () Alias for Maid.DoCleaning()  "},{"title":"new​","type":1,"pageTitle":"Maid","url":"/Evermore/api/Maid#new","content":"&lt;/&gt; Maid.new() → Maid Constructs a new Maid object local maid = Maid.new()   "},{"title":"isMaid​","type":1,"pageTitle":"Maid","url":"/Evermore/api/Maid#isMaid","content":"&lt;/&gt; Maid.isMaid(value: any) → boolean Returns true if the class is a maid, and false otherwise. print(Maid.isMaid(Maid.new())) --&gt; true print(Maid.isMaid(nil)) --&gt; false   "},{"title":"Destroy​","type":1,"pageTitle":"Maid","url":"/Evermore/api/Maid#Destroy","content":"&lt;/&gt; Maid.Destroy() → () Alias for Maid.DoCleaning()  "},{"title":"new​","type":1,"pageTitle":"Maid","url":"/Evermore/api/Maid#new","content":"&lt;/&gt; Maid.new() → Maid Constructs a new Maid object local maid = Maid.new()   "},{"title":"isMaid​","type":1,"pageTitle":"Maid","url":"/Evermore/api/Maid#isMaid","content":"&lt;/&gt; Maid.isMaid(value: any) → boolean Returns true if the class is a maid, and false otherwise. print(Maid.isMaid(Maid.new())) --&gt; true print(Maid.isMaid(nil)) --&gt; false   "},{"title":"Destroy​","type":1,"pageTitle":"Maid","url":"/Evermore/api/Maid#Destroy","content":"&lt;/&gt; Maid.Destroy() → () Alias for Maid.DoCleaning()  "},{"title":"__index​","type":1,"pageTitle":"Maid","url":"/Evermore/api/Maid#__index","content":"&lt;/&gt; Maid:__index(index: any) → MaidTask Returns Maid[key] if not part of Maid metatable local maid = Maid.new() maid._current = Instance.new(&quot;Part&quot;) print(maid._current) --&gt; Part maid._current = nil print(maid._current) --&gt; nil   "},{"title":"__newindex​","type":1,"pageTitle":"Maid","url":"/Evermore/api/Maid#__newindex","content":"&lt;/&gt; Maid:__newindex( index: any, newTask: MaidTask ) → () Add a task to clean up. Tasks given to a maid will be cleaned when maid[index] is set to a different value. Task cleanup is such that if the task is an event, it is disconnected. If it is an object, it is destroyed. Maid[key] = (function) Adds a task to perform Maid[key] = (event connection) Manages an event connection Maid[key] = (thread) Manages a thread Maid[key] = (Maid) Maids can act as an event connection, allowing a Maid to have other maids to clean up. Maid[key] = (Object) Maids can cleanup objects with a `Destroy` method Maid[key] = nil Removes a named task.   "},{"title":"GiveTask​","type":1,"pageTitle":"Maid","url":"/Evermore/api/Maid#GiveTask","content":"&lt;/&gt; Maid:GiveTask( task: MaidTask-- An item to clean ) → number-- taskId Gives a task to the maid for cleanup, but uses an incremented number as a key.  "},{"title":"GivePromise​","type":1,"pageTitle":"Maid","url":"/Evermore/api/Maid#GivePromise","content":"&lt;/&gt; Maid:GivePromise(promise: Promise&lt;T&gt;) → Promise&lt;T&gt; Gives a promise to the maid for clean.  "},{"title":"DoCleaning​","type":1,"pageTitle":"Maid","url":"/Evermore/api/Maid#DoCleaning","content":"&lt;/&gt; Maid:DoCleaning() → () Cleans up all tasks and removes them as entries from the Maid. note Signals that are already connected are always disconnected first. After that any signals added during a cleaning phase will be disconnected at random times. tip DoCleaning() may be recursively invoked. This allows the you to ensure that tasks or other tasks. Each task will be executed once. However, adding tasks while cleaning is not generally a good idea, as if you add a function that adds itself, this will loop indefinitely.  "},{"title":"__index​","type":1,"pageTitle":"Maid","url":"/Evermore/api/Maid#__index","content":"&lt;/&gt; Maid:__index(index: any) → MaidTask Returns Maid[key] if not part of Maid metatable local maid = Maid.new() maid._current = Instance.new(&quot;Part&quot;) print(maid._current) --&gt; Part maid._current = nil print(maid._current) --&gt; nil   "},{"title":"__newindex​","type":1,"pageTitle":"Maid","url":"/Evermore/api/Maid#__newindex","content":"&lt;/&gt; Maid:__newindex( index: any, newTask: MaidTask ) → () Add a task to clean up. Tasks given to a maid will be cleaned when maid[index] is set to a different value. Task cleanup is such that if the task is an event, it is disconnected. If it is an object, it is destroyed. Maid[key] = (function) Adds a task to perform Maid[key] = (event connection) Manages an event connection Maid[key] = (thread) Manages a thread Maid[key] = (Maid) Maids can act as an event connection, allowing a Maid to have other maids to clean up. Maid[key] = (Object) Maids can cleanup objects with a `Destroy` method Maid[key] = nil Removes a named task.   "},{"title":"GiveTask​","type":1,"pageTitle":"Maid","url":"/Evermore/api/Maid#GiveTask","content":"&lt;/&gt; Maid:GiveTask( task: MaidTask-- An item to clean ) → number-- taskId Gives a task to the maid for cleanup, but uses an incremented number as a key.  "},{"title":"GivePromise​","type":1,"pageTitle":"Maid","url":"/Evermore/api/Maid#GivePromise","content":"&lt;/&gt; Maid:GivePromise(promise: Promise&lt;T&gt;) → Promise&lt;T&gt; Gives a promise to the maid for clean.  "},{"title":"DoCleaning​","type":1,"pageTitle":"Maid","url":"/Evermore/api/Maid#DoCleaning","content":"&lt;/&gt; Maid:DoCleaning() → () Cleans up all tasks and removes them as entries from the Maid. note Signals that are already connected are always disconnected first. After that any signals added during a cleaning phase will be disconnected at random times. tip DoCleaning() may be recursively invoked. This allows the you to ensure that tasks or other tasks. Each task will be executed once. However, adding tasks while cleaning is not generally a good idea, as if you add a function that adds itself, this will loop indefinitely.  "},{"title":"__index​","type":1,"pageTitle":"Maid","url":"/Evermore/api/Maid#__index","content":"&lt;/&gt; Maid:__index(index: any) → MaidTask Returns Maid[key] if not part of Maid metatable local maid = Maid.new() maid._current = Instance.new(&quot;Part&quot;) print(maid._current) --&gt; Part maid._current = nil print(maid._current) --&gt; nil   "},{"title":"__newindex​","type":1,"pageTitle":"Maid","url":"/Evermore/api/Maid#__newindex","content":"&lt;/&gt; Maid:__newindex( index: any, newTask: MaidTask ) → () Add a task to clean up. Tasks given to a maid will be cleaned when maid[index] is set to a different value. Task cleanup is such that if the task is an event, it is disconnected. If it is an object, it is destroyed. Maid[key] = (function) Adds a task to perform Maid[key] = (event connection) Manages an event connection Maid[key] = (thread) Manages a thread Maid[key] = (Maid) Maids can act as an event connection, allowing a Maid to have other maids to clean up. Maid[key] = (Object) Maids can cleanup objects with a `Destroy` method Maid[key] = nil Removes a named task.   "},{"title":"GiveTask​","type":1,"pageTitle":"Maid","url":"/Evermore/api/Maid#GiveTask","content":"&lt;/&gt; Maid:GiveTask( task: MaidTask-- An item to clean ) → number-- taskId Gives a task to the maid for cleanup, but uses an incremented number as a key.  "},{"title":"GivePromise​","type":1,"pageTitle":"Maid","url":"/Evermore/api/Maid#GivePromise","content":"&lt;/&gt; Maid:GivePromise(promise: Promise&lt;T&gt;) → Promise&lt;T&gt; Gives a promise to the maid for clean.  "},{"title":"DoCleaning​","type":1,"pageTitle":"Maid","url":"/Evermore/api/Maid#DoCleaning","content":"&lt;/&gt; Maid:DoCleaning() → () Cleans up all tasks and removes them as entries from the Maid. note Signals that are already connected are always disconnected first. After that any signals added during a cleaning phase will be disconnected at random times. tip DoCleaning() may be recursively invoked. This allows the you to ensure that tasks or other tasks. Each task will be executed once. However, adding tasks while cleaning is not generally a good idea, as if you add a function that adds itself, this will loop indefinitely. "},{"title":"ReplicatorUtils","type":0,"sectionRef":"#","url":"/Evermore/api/ReplicatorUtils","content":"On this page ReplicatorUtils","keywords":""},{"title":"PromiseUtils","type":0,"sectionRef":"#","url":"/Evermore/api/PromiseUtils","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"PromiseUtils","url":"/Evermore/api/PromiseUtils#functions","content":" "},{"title":"any​","type":1,"pageTitle":"PromiseUtils","url":"/Evermore/api/PromiseUtils#any","content":"&lt;/&gt; PromiseUtils.any(promises: {Promise&lt;T&gt;}) → Promise&lt;T&gt;-- Promise that resolves with first result Returns the value of the first promise resolved  "},{"title":"all​","type":1,"pageTitle":"PromiseUtils","url":"/Evermore/api/PromiseUtils#all","content":"&lt;/&gt; PromiseUtils.all(promises: {Promise&lt;T&gt;}) → Promise&lt;T&gt; Executes all promises. If any fails, the result will be rejected. However, it yields until every promise is complete. warning Passing in a spare array (i.e. {nil, promise}) will result in undefined behavior here.  "},{"title":"combine​","type":1,"pageTitle":"PromiseUtils","url":"/Evermore/api/PromiseUtils#combine","content":"&lt;/&gt; PromiseUtils.combine(stateTable: any) → Promise&lt;any&gt; Combines the result of promises together  "},{"title":"invert​","type":1,"pageTitle":"PromiseUtils","url":"/Evermore/api/PromiseUtils#invert","content":"&lt;/&gt; PromiseUtils.invert(promise: Promise&lt;T&gt;) → Promise&lt;T&gt; Inverts the result of a promise, turning a resolved promise into a rejected one, and a rejected one into a resolved one.  "},{"title":"fromSignal​","type":1,"pageTitle":"PromiseUtils","url":"/Evermore/api/PromiseUtils#fromSignal","content":"&lt;/&gt; PromiseUtils.fromSignal(signal: Signal&lt;T&gt;) → Promise&lt;T&gt; Creates a promise from a signal  "},{"title":"timeout​","type":1,"pageTitle":"PromiseUtils","url":"/Evermore/api/PromiseUtils#timeout","content":"&lt;/&gt; PromiseUtils.timeout( timeoutTime: number, fromPromise: Promise&lt;T&gt; ) → Promise&lt;T&gt; Creates a new promise from the given promise that will reject after the given timeoutTime "},{"title":"Utils","type":0,"sectionRef":"#","url":"/Evermore/api/Utils","content":"On this page Utils This item is only intended to be used by the module's authors. Private","keywords":""},{"title":"Signal","type":0,"sectionRef":"#","url":"/Evermore/api/Signal","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Signal","url":"/Evermore/api/Signal#functions","content":" "},{"title":"isSignal​","type":1,"pageTitle":"Signal","url":"/Evermore/api/Signal#isSignal","content":"&lt;/&gt; Signal.isSignal(value: any) → boolean Returns whether a class is a signal  "},{"title":"new​","type":1,"pageTitle":"Signal","url":"/Evermore/api/Signal#new","content":"&lt;/&gt; Signal.new() → Signal&lt;T&gt; Constructs a new signal.  "},{"title":"Fire​","type":1,"pageTitle":"Signal","url":"/Evermore/api/Signal#Fire","content":"&lt;/&gt; Signal:Fire( ...: T-- Variable arguments to pass to handler ) → () Fire the event with the given arguments. All handlers will be invoked. Handlers follow  "},{"title":"Connect​","type":1,"pageTitle":"Signal","url":"/Evermore/api/Signal#Connect","content":"&lt;/&gt; Signal:Connect( handler: (...T) → ()-- Function handler called when :Fire(...) is called ) → RBXScriptConnection  Connect a new handler to the event. Returns a connection object that can be disconnected.  "},{"title":"Once​","type":1,"pageTitle":"Signal","url":"/Evermore/api/Signal#Once","content":"&lt;/&gt; Signal:Once( handler: (...T) → ()-- One-time function handler called when :Fire(...) is called ) → RBXScriptConnection  Connect a new, one-time handler to the event. Returns a connection object that can be disconnected.  "},{"title":"Wait​","type":1,"pageTitle":"Signal","url":"/Evermore/api/Signal#Wait","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Signal:Wait() → T Wait for fire to be called, and return the arguments it was given.  "},{"title":"Destroy​","type":1,"pageTitle":"Signal","url":"/Evermore/api/Signal#Destroy","content":"&lt;/&gt; Signal:Destroy() → () Disconnects all connected events to the signal. Voids the signal as unusable. Sets the metatable to nil. "},{"title":"ReplicatorReferences","type":0,"sectionRef":"#","url":"/Evermore/api/ReplicatorReferences","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"ReplicatorReferences","url":"/Evermore/api/ReplicatorReferences#functions","content":" "},{"title":"isReplicatorReferences​","type":1,"pageTitle":"ReplicatorReferences","url":"/Evermore/api/ReplicatorReferences#isReplicatorReferences","content":"&lt;/&gt; ReplicatorReferences.isReplicatorReferences(replicatorReferences: any?) → boolean Returns true if the argument is a replicator references  "},{"title":"isReplicatorReferences​","type":1,"pageTitle":"ReplicatorReferences","url":"/Evermore/api/ReplicatorReferences#isReplicatorReferences","content":"&lt;/&gt; ReplicatorReferences.isReplicatorReferences(replicatorReferences: any?) → boolean Returns true if the argument is a replicator references  "},{"title":"ObserveReferenceChanged​","type":1,"pageTitle":"ReplicatorReferences","url":"/Evermore/api/ReplicatorReferences#ObserveReferenceChanged","content":"&lt;/&gt; ReplicatorReferences:ObserveReferenceChanged( orig: Instance , callback: function ) → function-- Call to disconnect Observes when a reference changes. Discount Rx observable since we're the loader and don't want a whole copy of Rx.  "},{"title":"ObserveReferenceChanged​","type":1,"pageTitle":"ReplicatorReferences","url":"/Evermore/api/ReplicatorReferences#ObserveReferenceChanged","content":"&lt;/&gt; ReplicatorReferences:ObserveReferenceChanged( orig: Instance , callback: function ) → function-- Call to disconnect Observes when a reference changes. Discount Rx observable since we're the loader and don't want a whole copy of Rx. "},{"title":"SignalUtils","type":0,"sectionRef":"#","url":"/Evermore/api/SignalUtils","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"SignalUtils","url":"/Evermore/api/SignalUtils#functions","content":" "},{"title":"onNext​","type":1,"pageTitle":"SignalUtils","url":"/Evermore/api/SignalUtils#onNext","content":"&lt;/&gt; SignalUtils.onNext( event: RBXScriptSignal , _function: function ) → RBXScriptConnection  Executes on the next event connection. "},{"title":"Replicator","type":0,"sectionRef":"#","url":"/Evermore/api/Replicator","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Replicator","url":"/Evermore/api/Replicator#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Replicator","url":"/Evermore/api/Replicator#new","content":"&lt;/&gt; Replicator.new(references: ReplicatorReferences) → Replicator Constructs a new Replicator which will do the syncing.  "},{"title":"isReplicator​","type":1,"pageTitle":"Replicator","url":"/Evermore/api/Replicator#isReplicator","content":"&lt;/&gt; Replicator.isReplicator(replicator: any?) → boolean Returns true if the argument is a replicator  "},{"title":"new​","type":1,"pageTitle":"Replicator","url":"/Evermore/api/Replicator#new","content":"&lt;/&gt; Replicator.new(references: ReplicatorReferences) → Replicator Constructs a new Replicator which will do the syncing.  "},{"title":"isReplicator​","type":1,"pageTitle":"Replicator","url":"/Evermore/api/Replicator#isReplicator","content":"&lt;/&gt; Replicator.isReplicator(replicator: any?) → boolean Returns true if the argument is a replicator  "},{"title":"ReplicateFrom​","type":1,"pageTitle":"Replicator","url":"/Evermore/api/Replicator#ReplicateFrom","content":"&lt;/&gt; Replicator:ReplicateFrom(root: Instance ) → () Replicates children from the given root  "},{"title":"GetReplicatedDescendantCountValue​","type":1,"pageTitle":"Replicator","url":"/Evermore/api/Replicator#GetReplicatedDescendantCountValue","content":"&lt;/&gt; Replicator:GetReplicatedDescendantCountValue() → IntValue  Returns the replicated descendant count value.  "},{"title":"SetReplicationType​","type":1,"pageTitle":"Replicator","url":"/Evermore/api/Replicator#SetReplicationType","content":"&lt;/&gt; Replicator:SetReplicationType(replicationType: ReplicationType) → () Sets the replication type for this replicator  "},{"title":"SetTarget​","type":1,"pageTitle":"Replicator","url":"/Evermore/api/Replicator#SetTarget","content":"&lt;/&gt; Replicator:SetTarget(target: Instance? ) → () Sets the target for the replicator where the results will be parented.  "},{"title":"GetTarget​","type":1,"pageTitle":"Replicator","url":"/Evermore/api/Replicator#GetTarget","content":"&lt;/&gt; Replicator:GetTarget() → Instance?  Gets the current target for the replicator.  "},{"title":"GetHasReplicatedChildrenValue​","type":1,"pageTitle":"Replicator","url":"/Evermore/api/Replicator#GetHasReplicatedChildrenValue","content":"&lt;/&gt; Replicator:GetHasReplicatedChildrenValue() → BoolValue  Gets a value representing if there's any replicated children. Used to avoid leaking more server-side information than needed for the user.  "},{"title":"Destroy​","type":1,"pageTitle":"Replicator","url":"/Evermore/api/Replicator#Destroy","content":"&lt;/&gt; Replicator:Destroy() → () Cleans up the replicator disconnecting all events and cleaning up created instances.  "},{"title":"ReplicateFrom​","type":1,"pageTitle":"Replicator","url":"/Evermore/api/Replicator#ReplicateFrom","content":"&lt;/&gt; Replicator:ReplicateFrom(root: Instance ) → () Replicates children from the given root  "},{"title":"GetReplicatedDescendantCountValue​","type":1,"pageTitle":"Replicator","url":"/Evermore/api/Replicator#GetReplicatedDescendantCountValue","content":"&lt;/&gt; Replicator:GetReplicatedDescendantCountValue() → IntValue  Returns the replicated descendant count value.  "},{"title":"SetReplicationType​","type":1,"pageTitle":"Replicator","url":"/Evermore/api/Replicator#SetReplicationType","content":"&lt;/&gt; Replicator:SetReplicationType(replicationType: ReplicationType) → () Sets the replication type for this replicator  "},{"title":"SetTarget​","type":1,"pageTitle":"Replicator","url":"/Evermore/api/Replicator#SetTarget","content":"&lt;/&gt; Replicator:SetTarget(target: Instance? ) → () Sets the target for the replicator where the results will be parented.  "},{"title":"GetTarget​","type":1,"pageTitle":"Replicator","url":"/Evermore/api/Replicator#GetTarget","content":"&lt;/&gt; Replicator:GetTarget() → Instance?  Gets the current target for the replicator.  "},{"title":"GetHasReplicatedChildrenValue​","type":1,"pageTitle":"Replicator","url":"/Evermore/api/Replicator#GetHasReplicatedChildrenValue","content":"&lt;/&gt; Replicator:GetHasReplicatedChildrenValue() → BoolValue  Gets a value representing if there's any replicated children. Used to avoid leaking more server-side information than needed for the user.  "},{"title":"Destroy​","type":1,"pageTitle":"Replicator","url":"/Evermore/api/Replicator#Destroy","content":"&lt;/&gt; Replicator:Destroy() → () Cleans up the replicator disconnecting all events and cleaning up created instances. "},{"title":"Symbol","type":0,"sectionRef":"#","url":"/Evermore/api/Symbol","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Symbol","url":"/Evermore/api/Symbol#functions","content":" "},{"title":"named​","type":1,"pageTitle":"Symbol","url":"/Evermore/api/Symbol#named","content":"&lt;/&gt; Symbol.named(name: string) → Symbol Creates a Symbol with the given name. When printed or coerced to a string, the symbol will turn into the string given as its name. "},{"title":"ThrottledFunction","type":0,"sectionRef":"#","url":"/Evermore/api/ThrottledFunction","content":"On this page ThrottledFunction Throttles execution of a functon. Does both leading, and following","keywords":""},{"title":"Subscription","type":0,"sectionRef":"#","url":"/Evermore/api/Subscription","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Subscription","url":"/Evermore/api/Subscription#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Subscription","url":"/Evermore/api/Subscription#new","content":"&lt;/&gt; Subscription.new( fireCallback: function?, failCallback: function?, completeCallback: function?, onSubscribe: () → MaidTask ) → Subscription Constructs a new Subscription  "},{"title":"Fire​","type":1,"pageTitle":"Subscription","url":"/Evermore/api/Subscription#Fire","content":"&lt;/&gt; Subscription:Fire(...: any) → () Fires the subscription  "},{"title":"Fail​","type":1,"pageTitle":"Subscription","url":"/Evermore/api/Subscription#Fail","content":"&lt;/&gt; Subscription:Fail() → () Fails the subscription, preventing anything else from emitting.  "},{"title":"GetFireFailComplete​","type":1,"pageTitle":"Subscription","url":"/Evermore/api/Subscription#GetFireFailComplete","content":"&lt;/&gt; Subscription:GetFireFailComplete() → ( function, function, function ) Returns a tuple of fire, fail and complete functions which can be chained into the the next subscription. return function(source) return Observable.new(function(sub) sub:Fire(&quot;hi&quot;) return source:Subscribe(sub:GetFireFailComplete()) end) end   "},{"title":"GetFailComplete​","type":1,"pageTitle":"Subscription","url":"/Evermore/api/Subscription#GetFailComplete","content":"&lt;/&gt; Subscription:GetFailComplete() → ( function, function ) Returns a tuple of fail and complete functions which can be chained into the the next subscription. return function(source) return Observable.new(function(sub) return source:Subscribe(function(result) sub:Fire(tostring(result)) end, sub:GetFailComplete()) -- Reuse is easy here! end) end   "},{"title":"Complete​","type":1,"pageTitle":"Subscription","url":"/Evermore/api/Subscription#Complete","content":"&lt;/&gt; Subscription:Complete() → () Completes the subscription, preventing anything else from being emitted.  "},{"title":"IsPending​","type":1,"pageTitle":"Subscription","url":"/Evermore/api/Subscription#IsPending","content":"&lt;/&gt; Subscription:IsPending() → boolean Returns whether the subscription is pending.  "},{"title":"Destroy​","type":1,"pageTitle":"Subscription","url":"/Evermore/api/Subscription#Destroy","content":"&lt;/&gt; Subscription:Destroy() → () Cleans up the subscription tip This will be invoked by the Observable automatically, and should not be called within the usage of a subscription.  "},{"title":"Disconnect​","type":1,"pageTitle":"Subscription","url":"/Evermore/api/Subscription#Disconnect","content":"&lt;/&gt; Subscription:Disconnect() → () Alias for Subscription.Destroy. "},{"title":"throttle","type":0,"sectionRef":"#","url":"/Evermore/api/throttle","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"throttle","url":"/Evermore/api/throttle#functions","content":" "},{"title":"throttle​","type":1,"pageTitle":"throttle","url":"/Evermore/api/throttle#throttle","content":"&lt;/&gt; throttle.throttle( timeoutInSeconds: number, func: function, throttleConfig?: {leading=true;trailing=true;} ) → function Provides a debounce function call on an operation. "},{"title":"Promise","type":0,"sectionRef":"#","url":"/Evermore/api/Promise","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Promise","url":"/Evermore/api/Promise#functions","content":" "},{"title":"isPromise​","type":1,"pageTitle":"Promise","url":"/Evermore/api/Promise#isPromise","content":"&lt;/&gt; Promise.isPromise(value: any) → boolean Determines whether a value is a promise or not.  "},{"title":"new​","type":1,"pageTitle":"Promise","url":"/Evermore/api/Promise#new","content":"&lt;/&gt; Promise.new(func: ( resolve: (...) → (), reject: (...) → () ) → ()?) → Promise&lt;T&gt; Constructs a new promise. ::warning Do not yield within this func callback, as it will yield on the main thread. This is a performance optimization. ::  "},{"title":"spawn​","type":1,"pageTitle":"Promise","url":"/Evermore/api/Promise#spawn","content":"&lt;/&gt; Promise.spawn(func: ( resolve: (...) → (), reject: (...) → () ) → ()?) → Promise&lt;T&gt; Initializes a new promise with the given function in a deferred wrapper.  "},{"title":"defer​","type":1,"pageTitle":"Promise","url":"/Evermore/api/Promise#defer","content":"&lt;/&gt; Promise.defer(func: ( resolve: (...) → (), reject: (...) → () ) → ()?) → Promise&lt;T&gt; Initializes a new promise with the given function in a deferred wrapper.  "},{"title":"resolved​","type":1,"pageTitle":"Promise","url":"/Evermore/api/Promise#resolved","content":"&lt;/&gt; Promise.resolved(...: Valuestoresolveto) → Promise&lt;T&gt; Returns a resolved promise with the following values  "},{"title":"rejected​","type":1,"pageTitle":"Promise","url":"/Evermore/api/Promise#rejected","content":"&lt;/&gt; Promise.rejected(...: Valuestorejectto) → Promise&lt;T&gt; Returns a rejected promise with the following values  "},{"title":"IsPending​","type":1,"pageTitle":"Promise","url":"/Evermore/api/Promise#IsPending","content":"&lt;/&gt; Promise:IsPending() → bool-- True if pending, false otherwise Returns whether or not the promise is pending  "},{"title":"IsFulfilled​","type":1,"pageTitle":"Promise","url":"/Evermore/api/Promise#IsFulfilled","content":"&lt;/&gt; Promise:IsFulfilled() → bool-- True if fulfilled Returns whether or not the promise is fulfilled  "},{"title":"IsRejected​","type":1,"pageTitle":"Promise","url":"/Evermore/api/Promise#IsRejected","content":"&lt;/&gt; Promise:IsRejected() → bool-- True if rejected Returns whether or not the promise is rejected  "},{"title":"Wait​","type":1,"pageTitle":"Promise","url":"/Evermore/api/Promise#Wait","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Promise:Wait() → T Yields until the promise is complete, and errors if an error exists, otherwise returns the fulfilled results.  "},{"title":"Yield​","type":1,"pageTitle":"Promise","url":"/Evermore/api/Promise#Yield","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Promise:Yield() → boolean,T Yields until the promise is complete, then returns a boolean indicating the result, followed by the values from the promise.  "},{"title":"Resolve​","type":1,"pageTitle":"Promise","url":"/Evermore/api/Promise#Resolve","content":"&lt;/&gt; Promise:Resolve(...: T) → () Promise resolution procedure, resolves the given values  "},{"title":"Reject​","type":1,"pageTitle":"Promise","url":"/Evermore/api/Promise#Reject","content":"&lt;/&gt; Promise:Reject( ...: T-- Params to reject with ) → () Rejects the promise with the values given  "},{"title":"Then​","type":1,"pageTitle":"Promise","url":"/Evermore/api/Promise#Then","content":"&lt;/&gt; Promise:Then( onFulfilled: function,-- Called if/when fulfilled with parameters onRejected: function-- Called if/when rejected with parameters ) → Promise&lt;T&gt; Handlers if/when promise is fulfilled/rejected. It takes up to two arguments, callback functions for the success and failure cases of the Promise. May return the same promise if certain behavior is met. info We do not comply with 2.2.4 (onFulfilled or onRejected must not be called until the execution context stack contains only platform code). This means promises may stack overflow, however, it also makes promises a lot cheaper If/when promise is rejected, all respective onRejected callbacks must execute in the order of their originating calls to then. If/when promise is fulfilled, all respective onFulfilled callbacks must execute in the order of their originating calls to then.  "},{"title":"Tap​","type":1,"pageTitle":"Promise","url":"/Evermore/api/Promise#Tap","content":"&lt;/&gt; Promise:Tap( onFulfilled: function, onRejected: function ) → Promise&lt;T&gt;-- Returns self Like then, but the value passed down the chain is the resolved value of the promise, not the value returned from onFulfilled or onRejected Will still yield for the result if a promise is returned, but will discard the result.  "},{"title":"Finally​","type":1,"pageTitle":"Promise","url":"/Evermore/api/Promise#Finally","content":"&lt;/&gt; Promise:Finally(func: function) → Promise&lt;T&gt; Executes upon pending stop  "},{"title":"Catch​","type":1,"pageTitle":"Promise","url":"/Evermore/api/Promise#Catch","content":"&lt;/&gt; Promise:Catch(onRejected: function) → Promise&lt;T&gt; Catch errors from the promise  "},{"title":"Destroy​","type":1,"pageTitle":"Promise","url":"/Evermore/api/Promise#Destroy","content":"&lt;/&gt; Promise:Destroy() → () Rejects the current promise. Utility left for Maid task  "},{"title":"GetResults​","type":1,"pageTitle":"Promise","url":"/Evermore/api/Promise#GetResults","content":"&lt;/&gt; Promise:GetResults() → ( boolean,-- true if resolved, false otherwise. any ) Returns the results from the promise. warning This API surface will error if the promise is still pending. "},{"title":"Table","type":0,"sectionRef":"#","url":"/Evermore/api/Table","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Table","url":"/Evermore/api/Table#functions","content":" "},{"title":"append​","type":1,"pageTitle":"Table","url":"/Evermore/api/Table#append","content":"&lt;/&gt; Table.append( target: table,-- Table to append to source: table-- Table read from ) → table-- parameter table Concats target with source.  "},{"title":"merge​","type":1,"pageTitle":"Table","url":"/Evermore/api/Table#merge","content":"&lt;/&gt; Table.merge( orig: table,-- Original table new: table-- Result ) → table Shallow merges two tables without modifying either.  "},{"title":"reverse​","type":1,"pageTitle":"Table","url":"/Evermore/api/Table#reverse","content":"&lt;/&gt; Table.reverse( orig: table-- Original table ) → table Reverses the list and returns the reversed copy  "},{"title":"values​","type":1,"pageTitle":"Table","url":"/Evermore/api/Table#values","content":"&lt;/&gt; Table.values( source: table-- Table source to extract values from ) → table-- A list with all the values the table has Returns a list of all of the values that a table has.  "},{"title":"keys​","type":1,"pageTitle":"Table","url":"/Evermore/api/Table#keys","content":"&lt;/&gt; Table.keys( source: table-- Table source to extract keys from ) → table-- A list with all the keys the table has Returns a list of all of the keys that a table has. (In order of pairs)  "},{"title":"mergeLists​","type":1,"pageTitle":"Table","url":"/Evermore/api/Table#mergeLists","content":"&lt;/&gt; Table.mergeLists( orig: table,-- Original table new: table-- Result ) → table Shallow merges two lists without modifying either.  "},{"title":"swapKeyValue​","type":1,"pageTitle":"Table","url":"/Evermore/api/Table#swapKeyValue","content":"&lt;/&gt; Table.swapKeyValue( orig: table-- Original table ) → table Swaps keys with values, overwriting additional values if duplicated.  "},{"title":"toList​","type":1,"pageTitle":"Table","url":"/Evermore/api/Table#toList","content":"&lt;/&gt; Table.toList( _table: table-- Table to convert to a list ) → table Converts a table to a list.  "},{"title":"count​","type":1,"pageTitle":"Table","url":"/Evermore/api/Table#count","content":"&lt;/&gt; Table.count( _table: table-- Table to count ) → number-- count Counts the number of items in _table. Useful since __len on table in Lua 5.2 returns just the array length.  "},{"title":"Table.copy​","type":1,"pageTitle":"Table","url":"/Evermore/api/Table#Table.copy","content":"&lt;/&gt; Table.Table.copy( target: table-- Table to copy ) → table-- Result Shallow copies a table from target into a new table  "},{"title":"deepCopy​","type":1,"pageTitle":"Table","url":"/Evermore/api/Table#deepCopy","content":"&lt;/&gt; Table.deepCopy( target: table,-- Table to deep copy _context: table?-- Cntext to deepCopy the value in ) → table-- Result Deep copies a table including metatables  "},{"title":"deepOverwrite​","type":1,"pageTitle":"Table","url":"/Evermore/api/Table#deepOverwrite","content":"&lt;/&gt; Table.deepOverwrite( target: table,-- Target table source: table-- Table to read from ) → table-- target Overwrites a table's value  "},{"title":"getIndex​","type":1,"pageTitle":"Table","url":"/Evermore/api/Table#getIndex","content":"&lt;/&gt; Table.getIndex( haystack: table,-- To search in needle: Valuetosearchfor ) → ( Theindexofthevalue,iffound, nil-- if not found ) Gets an index by value, returning nil if no index is found.  "},{"title":"stringify​","type":1,"pageTitle":"Table","url":"/Evermore/api/Table#stringify","content":"&lt;/&gt; Table.stringify( _table: table,-- Table to stringify indent: number?,-- Indent level output: string?-- Output string, used recursively ) → string-- The table in string form Recursively prints the table. Does not handle recursive tables.  "},{"title":"contains​","type":1,"pageTitle":"Table","url":"/Evermore/api/Table#contains","content":"&lt;/&gt; Table.contains( _table: table,-- To search in for value value: any-- Value to search for ) → boolean-- true if within, false otherwise Returns whether value is within table  "},{"title":"overwrite​","type":1,"pageTitle":"Table","url":"/Evermore/api/Table#overwrite","content":"&lt;/&gt; Table.overwrite( target: table,-- Table to overwite source: table-- Source table to read from ) → table-- target Overwrites an existing table with the source values.  "},{"title":"take​","type":1,"pageTitle":"Table","url":"/Evermore/api/Table#take","content":"&lt;/&gt; Table.take( source: table,-- Source table to retrieve values from count: number-- Number of entries to take ) → table-- List with the entries retrieved Takes count entries from the table. If the table does not have that many entries, will return up to the number the table has to provide.  "},{"title":"readonly​","type":1,"pageTitle":"Table","url":"/Evermore/api/Table#readonly","content":"&lt;/&gt; Table.readonly( target: table-- Table to error on indexing ) → table-- The same table, with the metatable set to readonly Sets a metatable on a table such that it errors when indexing a nil value  "},{"title":"deepReadonly​","type":1,"pageTitle":"Table","url":"/Evermore/api/Table#deepReadonly","content":"&lt;/&gt; Table.deepReadonly( target: table-- Table to error on indexing ) → table-- The same table Recursively sets the table as ReadOnly "},{"title":"Rx","type":0,"sectionRef":"#","url":"/Evermore/api/Rx","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Rx","url":"/Evermore/api/Rx#properties","content":" "},{"title":"EMPTY​","type":1,"pageTitle":"Rx","url":"/Evermore/api/Rx#EMPTY","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; Rx.EMPTY: Observable&lt;()&gt; An empty observable that completes immediately  "},{"title":"NEVER​","type":1,"pageTitle":"Rx","url":"/Evermore/api/Rx#NEVER","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; Rx.NEVER: Observable&lt;()&gt; An observable that never completes. "},{"title":"Functions​","type":1,"pageTitle":"Rx","url":"/Evermore/api/Rx#functions","content":" "},{"title":"pipe​","type":1,"pageTitle":"Rx","url":"/Evermore/api/Rx#pipe","content":"&lt;/&gt; Rx.pipe(transformers: {Observable&lt;any&gt;}) → (source: Observable&lt;T&gt;) → Observable&lt;U&gt; Pipes the tranformers through each otherhttps://rxjs-dev.firebaseapp.com/api/index/function/pipe  "},{"title":"of​","type":1,"pageTitle":"Rx","url":"/Evermore/api/Rx#of","content":"&lt;/&gt; Rx.of( ...: any-- Arguments to emit ) → Observable http://reactivex.io/documentation/operators/just.html Rx.of(1, 2, 3):Subscribe(print, function() print(&quot;Complete&quot;) end)) --&gt; 1, 2, 3, &quot;Complete&quot;   "},{"title":"failed​","type":1,"pageTitle":"Rx","url":"/Evermore/api/Rx#failed","content":"&lt;/&gt; Rx.failed( ...: any-- Failure args ) → Observable Returns a failed observable  "},{"title":"from​","type":1,"pageTitle":"Rx","url":"/Evermore/api/Rx#from","content":"&lt;/&gt; Rx.from(item: Promise | table) → Observable Converts an itemhttp://reactivex.io/documentation/operators/from.html  "},{"title":"toPromise​","type":1,"pageTitle":"Rx","url":"/Evermore/api/Rx#toPromise","content":"&lt;/&gt; Rx.toPromise( observable: Observable&lt;T&gt;, cancelToken: CancelToken? ) → Promise&lt;T&gt; Converts a promise to an observable.  "},{"title":"merge​","type":1,"pageTitle":"Rx","url":"/Evermore/api/Rx#merge","content":"&lt;/&gt; Rx.merge(observables: {Observable}) → Observable https://rxjs-dev.firebaseapp.com/api/operators/merge  "},{"title":"fromSignal​","type":1,"pageTitle":"Rx","url":"/Evermore/api/Rx#fromSignal","content":"&lt;/&gt; Rx.fromSignal(event: Signal&lt;T&gt;) → Observable&lt;T&gt; Converts a Signal into an observable.https://rxjs-dev.firebaseapp.com/api/index/function/fromEvent  "},{"title":"fromPromise​","type":1,"pageTitle":"Rx","url":"/Evermore/api/Rx#fromPromise","content":"&lt;/&gt; Rx.fromPromise(promise: Promise&lt;T&gt;) → Observable&lt;T&gt; Converts a Promise into an observable.https://rxjs-dev.firebaseapp.com/api/index/function/from  "},{"title":"tap​","type":1,"pageTitle":"Rx","url":"/Evermore/api/Rx#tap","content":"&lt;/&gt; Rx.tap( onFire: function?, onError: function?, onComplete: function? ) → (source: Observable&lt;T&gt;) → Observable&lt;T&gt; Taps into the observable and executes the onFire/onError/onComplete commands. https://rxjs-dev.firebaseapp.com/api/operators/tap  "},{"title":"start​","type":1,"pageTitle":"Rx","url":"/Evermore/api/Rx#start","content":"&lt;/&gt; Rx.start(callback: function) → (source: Observable) → Observable Starts the observable with the given value from the callback http://reactivex.io/documentation/operators/start.html  "},{"title":"share​","type":1,"pageTitle":"Rx","url":"/Evermore/api/Rx#share","content":"&lt;/&gt; Rx.share() → (source: Observable) → Observable Returns a new Observable that multicasts (shares) the original Observable. As long as there is at least one Subscriber this Observable will be subscribed and emitting data. When all subscribers have unsubscribed it will unsubscribe from the source Observable. https://rxjs.dev/api/operators/share  "},{"title":"shareReplay​","type":1,"pageTitle":"Rx","url":"/Evermore/api/Rx#shareReplay","content":"&lt;/&gt; Rx.shareReplay( bufferSize: number,-- Number of entries to cache windowTimeSeconds: number-- Time ) → (source: Observable) → Observable Same as Rx.share except it also replays the value  "},{"title":"cache​","type":1,"pageTitle":"Rx","url":"/Evermore/api/Rx#cache","content":"&lt;/&gt; Rx.cache() → (source: Observable) → Observable Caches the current value  "},{"title":"startFrom​","type":1,"pageTitle":"Rx","url":"/Evermore/api/Rx#startFrom","content":"&lt;/&gt; Rx.startFrom(callback: () → {T}) → (source: Observable) → Observable Like start, but also from (list!)  "},{"title":"startWith​","type":1,"pageTitle":"Rx","url":"/Evermore/api/Rx#startWith","content":"&lt;/&gt; Rx.startWith(values: {T}) → (source: Observable) → Observable Starts with the given valueshttps://rxjs-dev.firebaseapp.com/api/operators/startWith  "},{"title":"scan​","type":1,"pageTitle":"Rx","url":"/Evermore/api/Rx#scan","content":"&lt;/&gt; Rx.scan( reducer: function, seed: any | nil ) → (source: Observable) → Observable The Scan operator applies a function to the first item emitted by the source Observable and then emits the result of that function as its own first emission. It also feeds the result of the function back into the function along with the second item emitted by the source Observable in order to generate its second emission. It continues to feed back its own subsequent emissions along with the subsequent emissions from the source Observable in order to create the rest of its sequence. https://reactivex.io/documentation/operators/scan.html  "},{"title":"reduce​","type":1,"pageTitle":"Rx","url":"/Evermore/api/Rx#reduce","content":"&lt;/&gt; Rx.reduce( reducer: function, seed: any | nil ) → (source: Observable) → Observable The Reduce operator applies a function to the first item emitted by the source Observable and then feeds the result of the function back into the function along with the second item emitted by the source Observable, continuing this process until the source Observable emits its final item and completes, whereupon the Observable returned from Reduce emits the final value returned from the function. https://reactivex.io/documentation/operators/reduce.html  "},{"title":"defaultsTo​","type":1,"pageTitle":"Rx","url":"/Evermore/api/Rx#defaultsTo","content":"&lt;/&gt; Rx.defaultsTo(value: any) → (source: Observable) → Observable Defaults the observable to a value if it isn't fired immediately Rx.NEVER:Pipe({ Rx.defaultsTo(&quot;Hello&quot;) }):Subscribe(print) --&gt; Hello   "},{"title":"defaultsToNil​","type":1,"pageTitle":"Rx","url":"/Evermore/api/Rx#defaultsToNil","content":"&lt;/&gt; Rx.defaultsToNil(source: Observable) → Observable Defaults the observable value to nil Rx.NEVER:Pipe({ Rx.defaultsToNil }):Subscribe(print) --&gt; nil Great for defaulting Roblox attributes and objects  "},{"title":"endWith​","type":1,"pageTitle":"Rx","url":"/Evermore/api/Rx#endWith","content":"&lt;/&gt; Rx.endWith(values: {T}) → (source: Observable) → Observable Ends the observable with these values before cancellationhttps://www.learnrxjs.io/learn-rxjs/operators/combination/endwith  "},{"title":"where​","type":1,"pageTitle":"Rx","url":"/Evermore/api/Rx#where","content":"&lt;/&gt; Rx.where(predicate: (value: T) → boolean) → (source: Observable&lt;T&gt;) → Observable&lt;T&gt; http://reactivex.io/documentation/operators/filter.html Filters out values Rx.of(1, 2, 3, 4, 5):Pipe({ Rx.where(function(value) return value % 2 == 0; end) }):Subscribe(print) --&gt; 2, 4   "},{"title":"distinct​","type":1,"pageTitle":"Rx","url":"/Evermore/api/Rx#distinct","content":"&lt;/&gt; Rx.distinct() → (source: Observable&lt;T&gt;) → Observable&lt;T&gt; Only takes distinct values from the observable stream. http://reactivex.io/documentation/operators/distinct.html Rx.of(1, 1, 2, 3, 3, 1):Pipe({ Rx.distinct(); }):Subscribe(print) --&gt; 1, 2, 3, 1   "},{"title":"mapTo​","type":1,"pageTitle":"Rx","url":"/Evermore/api/Rx#mapTo","content":"&lt;/&gt; Rx.mapTo( ...: any-- The value to map each source value to. ) → (source: Observable&lt;T&gt;) → Observable&lt;T&gt; https://rxjs.dev/api/operators/mapTo  "},{"title":"map​","type":1,"pageTitle":"Rx","url":"/Evermore/api/Rx#map","content":"&lt;/&gt; Rx.map(project: (T) → U) → (source: Observable&lt;T&gt;) → Observable&lt;U&gt; http://reactivex.io/documentation/operators/map.html Maps one value to another Rx.of(1, 2, 3, 4, 5):Pipe({ Rx.map(function(x) return x + 1 end) }):Subscribe(print) -&gt; 2, 3, 4, 5, 6   "},{"title":"mergeAll​","type":1,"pageTitle":"Rx","url":"/Evermore/api/Rx#mergeAll","content":"&lt;/&gt; Rx.mergeAll() → (source: Observable&lt;Observable&lt;T&gt;&gt;) → Observable&lt;T&gt; Merges higher order observables together. Basically, if you have an observable that is emitting an observable, this subscribes to each emitted observable and combines them into a single observable. Rx.of(Rx.of(1, 2, 3), Rx.of(4)) :Pipe({ Rx.mergeAll(); }) :Subscribe(print) -&gt; 1, 2, 3, 4   "},{"title":"switchAll​","type":1,"pageTitle":"Rx","url":"/Evermore/api/Rx#switchAll","content":"&lt;/&gt; Rx.switchAll() → (source: Observable&lt;Observable&lt;T&gt;&gt;) → Observable&lt;T&gt; Merges higher order observables together https://rxjs.dev/api/operators/switchAll Works like mergeAll, where you subscribe to an observable which is emitting observables. However, when another observable is emitted it disconnects from the other observable and subscribes to that one.  "},{"title":"flatMap​","type":1,"pageTitle":"Rx","url":"/Evermore/api/Rx#flatMap","content":"&lt;/&gt; Rx.flatMap( project: (value: T) → Observable&lt;U&gt;, resultSelector: (( initialValue: T, outputValue: U ) → U)? ) → (source: Observable&lt;T&gt;) → Observable&lt;U&gt; Sort of equivalent of promise.then() This takes a stream of observables  "},{"title":"switchMap​","type":1,"pageTitle":"Rx","url":"/Evermore/api/Rx#switchMap","content":"&lt;/&gt; Rx.switchMap(project: function) → Observable Switches to a new observable from the current observable https://rxjs.dev/api/operators/switchMap As each observable shows up, a new observable is mapped from that observable. The old observable is disconnected. Use Rx.switchMap to switch to a new RunService event Rx.of(1, 2, 3):Pipe({ Rx.switchMap(function(value) local startTime = os.clock() -- Only the last observable returned will continue to emit, -- others are disconnected. return Rx.of(RunService.RenderStepped):Pipe({ Rx.map(function() return os.clock() - startTime, value end); }); end); }):Subscribe(print) --&gt; 0.002352342, 3 Use Rx.switchMap() as a simple map... Rx.of(1, 2, 3):Pipe({ Rx.switchMap(function(value) print(value) --&gt; 1 (and then 2, and then 3) return Rx.of(value*2) end); }):Subscribe(print) --&gt; 2, 4, 6 Use Rx.switchMap() with delayed input (to swap to a new one) Rx.of(1, 2, 3):Pipe({ Rx.switchMap(function(value) -- Emit 1 second later return Rx.of(value*2):Pipe({ Rx.delay(1); -- These will each get cancelled }) end); }):Subscribe(print) --&gt; 6 (other results were cancelled)   "},{"title":"packed​","type":1,"pageTitle":"Rx","url":"/Evermore/api/Rx#packed","content":"&lt;/&gt; Rx.packed(...: any) → Observable Returns an observable that takes in a tuple, and emits that tuple, then completes. Rx.packed(&quot;a&quot;, &quot;b&quot;) :Subscribe(function(first, second) print(first, second) --&gt; a, b end)   "},{"title":"unpacked​","type":1,"pageTitle":"Rx","url":"/Evermore/api/Rx#unpacked","content":"&lt;/&gt; Rx.unpacked(observable: Observable&lt;{T}&gt;) → Observable&lt;T&gt; Unpacks the observables value if a table is received  "},{"title":"finalize​","type":1,"pageTitle":"Rx","url":"/Evermore/api/Rx#finalize","content":"&lt;/&gt; Rx.finalize(finalizerCallback: () → ()) → (source: Observable&lt;T&gt;) → Observable&lt;T&gt; Acts as a finalizer callback once the subscription is unsubscribed. Rx.of(&quot;a&quot;, &quot;b&quot;):Pipe({ Rx.finalize(function() print(&quot;Subscription done!&quot;) end); }) http://reactivex.io/documentation/operators/do.html https://rxjs-dev.firebaseapp.com/api/operators/finalize https://github.com/ReactiveX/rxjs/blob/master/src/internal/operators/finalize.ts  "},{"title":"combineLatestAll​","type":1,"pageTitle":"Rx","url":"/Evermore/api/Rx#combineLatestAll","content":"&lt;/&gt; Rx.combineLatestAll() → (source: Observable&lt;Observable&lt;T&gt;&gt;) → Observable&lt;{T}&gt; Given an observable that emits observables, emit an observable that once the initial observable completes, the latest values of each emitted observable will be combined into an array that will be emitted. https://rxjs.dev/api/operators/combineLatestAll  "},{"title":"catchError​","type":1,"pageTitle":"Rx","url":"/Evermore/api/Rx#catchError","content":"&lt;/&gt; Rx.catchError(callback: (error: TError) → Observable&lt;TErrorResult&gt;) → (source: Observable&lt;T&gt;) → Observable&lt;T | TErrorResult&gt; Catches an error, and allows another observable to be subscribed in terms of handling the error. warning This method is not yet tested  "},{"title":"combineLatest​","type":1,"pageTitle":"Rx","url":"/Evermore/api/Rx#combineLatest","content":"&lt;/&gt; Rx.combineLatest(observables: {[TKey]: Observable&lt;TEmitted&gt; | TEmitted}) → Observable&lt;{[TKey]: TEmitted}&gt; One of the most useful functions this combines the latest values of observables at each chance! Rx.combineLatest({ child = Rx.fromSignal(Workspace.ChildAdded); lastChildRemoved = Rx.fromSignal(Workspace.ChildRemoved); value = 5; }):Subscribe(function(data) print(data.child) --&gt; last child print(data.lastChildRemoved) --&gt; other value print(data.value) --&gt; 5 end) tip Note that the resulting observable will not emit until all input observables are emitted.  "},{"title":"using​","type":1,"pageTitle":"Rx","url":"/Evermore/api/Rx#using","content":"&lt;/&gt; Rx.using( resourceFactory: () → MaidTask, observableFactory: (MaidTask) → Observable&lt;T&gt; ) → Observable&lt;T&gt; http://reactivex.io/documentation/operators/using.html Each time a subscription occurs, the resource is constructed and exists for the lifetime of the observation. The observableFactory uses the resource for subscription. note Note from Quenty: I haven't found this that useful.  "},{"title":"first​","type":1,"pageTitle":"Rx","url":"/Evermore/api/Rx#first","content":"&lt;/&gt; Rx.first() → (source: Observable&lt;T&gt;) → Observable&lt;T&gt; Takes the first entry and terminates the observable. Equivalent to the following: Rx.take(1) https://reactivex.io/documentation/operators/first.html  "},{"title":"take​","type":1,"pageTitle":"Rx","url":"/Evermore/api/Rx#take","content":"&lt;/&gt; Rx.take(number: number) → (source: Observable&lt;T&gt;) → Observable&lt;T&gt; Takes n entries and then completes the observation. https://rxjs.dev/api/operators/take  "},{"title":"skip​","type":1,"pageTitle":"Rx","url":"/Evermore/api/Rx#skip","content":"&lt;/&gt; Rx.skip(toSkip: number) → (source: Observable&lt;T&gt;) → Observable&lt;T&gt; Takes n entries and then completes the observation. https://rxjs.dev/api/operators/take  "},{"title":"defer​","type":1,"pageTitle":"Rx","url":"/Evermore/api/Rx#defer","content":"&lt;/&gt; Rx.defer(observableFactory: () → Observable&lt;T&gt;) → Observable&lt;T&gt; Defers the subscription and creation of the observable until the actual subscription of the observable. https://rxjs-dev.firebaseapp.com/api/index/function/defer https://netbasal.com/getting-to-know-the-defer-observable-in-rxjs-a16f092d8c09  "},{"title":"delay​","type":1,"pageTitle":"Rx","url":"/Evermore/api/Rx#delay","content":"&lt;/&gt; Rx.delay(seconds: number) → (source: Observable&lt;T&gt;) → Observable&lt;T&gt; Shift the emissions from an Observable forward in time by a particular amount.  "},{"title":"timer​","type":1,"pageTitle":"Rx","url":"/Evermore/api/Rx#timer","content":"&lt;/&gt; Rx.timer( initialDelaySeconds: number, seconds: number ) → (source: Observable&lt;number&gt;) → Observable&lt;number&gt; Emits output every n seconds  "},{"title":"interval​","type":1,"pageTitle":"Rx","url":"/Evermore/api/Rx#interval","content":"&lt;/&gt; Rx.interval(seconds: number) → (source: Observable&lt;number&gt;) → Observable&lt;number&gt; https://www.learnrxjs.io/learn-rxjs/operators/creation/interval  "},{"title":"withLatestFrom​","type":1,"pageTitle":"Rx","url":"/Evermore/api/Rx#withLatestFrom","content":"&lt;/&gt; Rx.withLatestFrom(inputObservables: {Observable&lt;TInput&gt;}) → (source: Observable&lt;T&gt;) → Observable&lt;{ T, ...TInput }&gt; Honestly, I have not used this one much. https://rxjs-dev.firebaseapp.com/api/operators/withLatestFrom https://medium.com/js-in-action/rxjs-nosy-combinelatest-vs-selfish-withlatestfrom-a957e1af42bf  "},{"title":"scan​","type":1,"pageTitle":"Rx","url":"/Evermore/api/Rx#scan","content":"&lt;/&gt; Rx.scan( accumulator: ( current: TSeed, ...: TInput ) → TResult, seed: TSeed ) → (source: Observable&lt;TInput&gt;) → Observable&lt;TResult&gt; https://rxjs-dev.firebaseapp.com/api/operators/scan  "},{"title":"throttleTime​","type":1,"pageTitle":"Rx","url":"/Evermore/api/Rx#throttleTime","content":"&lt;/&gt; Rx.throttleTime( duration: number, throttleConfig: {leading=true;trailing=true;} ) → (source: Observable) → Observable Throttles emission of observables. https://rxjs-dev.firebaseapp.com/api/operators/throttleTime note Note that on complete, the last item is not included, for now, unlike the existing version in rxjs.  "},{"title":"onlyAfterDefer​","type":1,"pageTitle":"Rx","url":"/Evermore/api/Rx#onlyAfterDefer","content":"&lt;/&gt; Rx.onlyAfterDefer() → (source: Observable) → Observable Only emits events after the deferred first signal.  "},{"title":"throttleDefer​","type":1,"pageTitle":"Rx","url":"/Evermore/api/Rx#throttleDefer","content":"&lt;/&gt; Rx.throttleDefer() → (source: Observable) → Observable Throttles emission of observables on the defer stack to the last emission.  "},{"title":"throttle​","type":1,"pageTitle":"Rx","url":"/Evermore/api/Rx#throttle","content":"&lt;/&gt; Rx.throttle(durationSelector: (T: value) → Observable) → (source: Observable&lt;T&gt;) → Observable&lt;T&gt; Throttles emission of observables on the defer stack to the last emission. https://rxjs.dev/api/operators/throttle  "},{"title":"combineAll​","type":1,"pageTitle":"Rx","url":"/Evermore/api/Rx#combineAll","content":"deprecated in 1.0.0 &lt;/&gt; This was deprecated in 1.0.0 Use Rx.combineLatestAll Rx.combineAll() → (source: Observable&lt;Observable&lt;T&gt;&gt;) → Observable&lt;{T}&gt; The same as combineLatestAll. This is for backwards compatability, and is deprecated. "}]